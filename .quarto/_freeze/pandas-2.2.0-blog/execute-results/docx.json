{
  "hash": "dfa8df52881c377b4c3936291ec95ca4",
  "result": {
    "markdown": "---\ntitle: \"How to use pandas `case_when()`\"\nsubtitle: \"And other new features in pandas 2.2.0\"\nAuthor: \"Michael Walshe\"\nformat:\n  html:\n    df-print: kable\n    mainfont: Arial\n    embed-resources: true\n  docx:\n    reference-doc: kd-quarto-ref-doc.docx\n    df-print: default\n    fig-align: center\n  gfm: default\n---\n\nPandas is the most popular Python package for data manipulation and analysis, providing a high-level tool for flexible manipulation of data in a tabular format. It just released version 2.2.0, the second minor release in the 2.0 series, and likely the last minor release before pandas 3.0 is scheduled to arrive in April!\n\nIncluded are several new features, some bug fixes, deprecations, and performance enhancements. I'm going to demonstrate a few of the most notable changes, however for a full overview please see the [release notes](https://pandas.pydata.org/docs/whatsnew/v2.2.0.html).\n\n\n\n# A new Series method: `Series.case_when`\n\n## Overview\n\nThe first new feature is a new method for a Series, that allows you to conditionally replace values based on a set of conditions. This is the most exciting change in 2.2.0 for me, as it's something that I and the community have been requesting for a long time (see various StackOverflow posts with over 2m collective views at [1]((https://stackoverflow.com/questions/49228596/pandas-case-when-default-in-pandas)), [2](https://stackoverflow.com/questions/26886653/create-new-column-based-on-values-from-other-columns-apply-a-function-of-multi), and [3](https://stackoverflow.com/questions/19913659/how-do-i-create-a-new-column-where-the-values-are-selected-based-on-existing-col)). \n\n\nPreviously, there were several different ways to conditionally create or alter columns in pandas: [`np.select`](https://numpy.org/doc/stable/reference/generated/numpy.select.html), [`np.where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html), [`Series.where`](https://pandas.pydata.org/docs/reference/api/pandas.Series.where.html), [`Series.mask`](https://pandas.pydata.org/docs/reference/api/pandas.Series.mask.html), and of course [`<Series/DataFrame>.loc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html). All of these have their place, but for the use-case of checking a *series* of conditions and returning values they all had problems, from readability to requiring you to use functionality outside of pandas. A new pandas function that cleanly solves this common problem in data wrangling has been long overdue!\n\n## Example\n\nLet's create an example dataframe:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(42)\n\ndf = pd.DataFrame(\n    {\n        \"A\": np.random.choice(list(\"ABC\"), 50),\n        \"B\": np.random.choice(list(\"XYZ\"), 50),\n        \"C\": np.random.random(50)*2 - 1,\n        \"D\": pd.date_range(\"2020-01-01\", periods=50, freq=\"D\"),\n    }\n)\n\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>A</th>\n      <th>B</th>\n      <th>C</th>\n      <th>D</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C</td>\n      <td>Y</td>\n      <td>-0.602569</td>\n      <td>2020-01-01</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>A</td>\n      <td>X</td>\n      <td>-0.988956</td>\n      <td>2020-01-02</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C</td>\n      <td>Y</td>\n      <td>0.630923</td>\n      <td>2020-01-03</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C</td>\n      <td>X</td>\n      <td>0.413715</td>\n      <td>2020-01-04</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>A</td>\n      <td>Y</td>\n      <td>0.458014</td>\n      <td>2020-01-05</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\nNow we can create a new column in that dataframe based on an existing column using `case_when`:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# The only argument to case_when is a list of tuples\n# of the form: (condition, value)\ndf[\"E\"] = df[\"A\"].case_when(\n    [\n        (df[\"A\"] == \"A\", \"A is A\"),\n        (df[\"B\"] == \"X\", \"B is X\"),\n    ]\n)\n\ndf[[\"A\", \"B\", \"E\"]].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>A</th>\n      <th>B</th>\n      <th>E</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C</td>\n      <td>Y</td>\n      <td>C</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>A</td>\n      <td>X</td>\n      <td>A is A</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C</td>\n      <td>Y</td>\n      <td>C</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C</td>\n      <td>X</td>\n      <td>B is X</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>A</td>\n      <td>Y</td>\n      <td>A is A</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\nNote two important things:\n\n- The conditions are applied such that if a condition is `True`, then the remaining conditions are **ignored** (*Note: this isn't how it's implemented, so there are no performance improvements from  \"short-circuiting\"*)\n- The default values used (for when no conditions match) are the values from the original `Series`\n\nWe can also use `Callables` (a function) for the conditions or replacements, these will be passed the Series that `case_when` is called on as an argument, for example:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndf[\"E\"] = df[\"A\"].case_when(\n    [\n        (df[\"D\"].dt.is_month_start, lambda s: s + \": At month start\"),\n        (lambda s: s == \"A\", df[\"A\"] + \"A\")\n    ]\n)\n\ndf[[\"A\", \"D\", \"E\"]].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>A</th>\n      <th>D</th>\n      <th>E</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C</td>\n      <td>2020-01-01</td>\n      <td>C: At month start</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>A</td>\n      <td>2020-01-02</td>\n      <td>AA</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C</td>\n      <td>2020-01-03</td>\n      <td>C</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C</td>\n      <td>2020-01-04</td>\n      <td>C</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>A</td>\n      <td>2020-01-05</td>\n      <td>AA</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\nAs a final handy trick, if you want to use your own default value, you can either create a new constant Series to use as the input, or have a final condition in your `caselist` argument that is always true:\n\n- Method 1:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf[\"E\"] = pd.Series(np.nan, index=df.index).case_when(\n    [\n        (df[\"A\"] == \"A\", 0),\n        (df[\"C\"] < 0.25, -df[\"C\"]),\n    ]\n)\n\ndf[[\"E\"]].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>E</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.602569</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n- Method 2:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndf[\"E\"] = df[\"C\"].case_when(\n    [\n        (df[\"A\"] == \"A\", 0),\n        (df[\"C\"] < 0.25, -df[\"C\"]),\n        (pd.Series(True), np.nan)\n    ]\n)\n\ndf[[\"E\"]].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>E</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.602569</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n# More performant database drivers with ADBC\n\n## Overview\n\nPandas now supports [Arrow ADBC drivers](https://arrow.apache.org/adbc/current/index.html) when reading from or writing to a database. This leads to much better performance, better type handling, and is part of the general move to a pandas backed by Arrow as well as NumPy.\n\n## Example\n\nHere I'll connect to a local SQLite database with SQLAlchemy, and using the ADBC drivers. As we'll see, using these (not very scientific) benchmarks we get a huge performance improvement!\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport timeit\n\nimport adbc_driver_sqlite.dbapi\nimport sqlalchemy as sa\n\nengine = sa.create_engine(\"sqlite:///temp.db\")\n\nwith (\n    engine.connect() as conn1,\n    adbc_driver_sqlite.dbapi.connect(\"temp.db\") as conn2,\n):\n    df = pd.DataFrame(\n        np.random.randint(10_000, size=(100_000, 10)), columns=list(\"abcdefghij\")\n    )\n\n    print(\n        \"Writing using the default driver: \",\n        timeit.timeit(lambda: df.to_sql(\"TEST\", conn1, if_exists=\"replace\"), number=10),\n    )\n    print(\n        \"Writing using ADBC: \",\n        timeit.timeit(lambda: df.to_sql(\"TEST\", conn2, if_exists=\"replace\"), number=10),\n    )\n    print(\n        \"Reading using the default driver: \",\n        timeit.timeit(lambda: pd.read_sql(\"TEST\", conn1), number=10),\n    )\n    print(\n        \"Reading using ADBC: \",\n        timeit.timeit(lambda: pd.read_sql(\"TEST\", conn2), number=10),\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWriting using the default driver:  8.99201579997316\nWriting using ADBC:  2.3864834000123665\nReading using the default driver:  4.350882900005672\nReading using ADBC:  0.5996618999633938\n```\n:::\n:::\n\n\n<br>\n\n# Improved Functionality for Processing Structured Columns\n\n## Overview\n\nThe final new feature I'll mention is again part of the move to an Arrow backed pandas. There is now more functionality and support for nested PyArrow data, with the `struct` and `list` Series accessors. This makes working with columns that contain structured data (such as list columns or custom structures) much easier. There are only a few methods at the moment, but this could be the start of array & struct columns as first class citizens in pandas.\n\n## Example\n\nOften, you may receive structured data via JSON, such as the below:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom io import StringIO\nimport pyarrow as pa\n\nraw_data = StringIO(\n    \"\"\"\n    [\n        {\"A\": [1, 2, 3],},\n        {\"A\": [4, 5]},\n        {\"A\": [6]}\n    ]\n    \"\"\"\n)\n\ndf = pd.read_json(\n    raw_data,\n    dtype=pd.ArrowDtype(pa.list_(pa.int64())),\n)\n\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>A</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>[1 2 3]</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>[4 5]</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>[6]</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\nWe can now use built-in pandas methods to interact with these PyArrow structures:\n\n- List Accessors:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndf[\"A\"].list[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n0    1\n1    4\n2    6\ndtype: int64[pyarrow]\n```\n:::\n:::\n\n\n- List Functions:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndf[\"A\"].list.flatten()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n0    1\n1    2\n2    3\n3    4\n4    5\n5    6\ndtype: int64[pyarrow]\n```\n:::\n:::\n\n\nThat's all for today, but check back in for our blog going over the key features and what to watch out for in pandas 3.0 when it lands!\n\n",
    "supporting": [
      "pandas-2.2.0-blog_files\\figure-docx"
    ],
    "filters": []
  }
}